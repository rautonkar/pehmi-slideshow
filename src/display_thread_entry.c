#include "display_thread.h"

#include "bsp_api.h"
#include "gx_api.h"
#include "guix/inc/certview_specifications.h"
#include "guix/inc/certview_resources.h"

#include "message.h"

#define TIMER_ID            (100)
#define TIMER_INIT_TICKS    (150)
#define RGB_BUFFER_SIZE     (800U*480U*3U)

#define DISPLAY_IMAGE_BUFFER_LOADED     (0x1U)

#if defined(BSP_BOARD_S7G2_SK)
#include "hardware/lcd.h"
#endif

/***********************************************************************************************************************
    Private function prototypes
 ***********************************************************************************************************************/
static bool ssp_touch_to_guix(sf_touch_panel_payload_t * p_touch_payload, GX_EVENT * g_gx_event);
void main_thread_entry(void);

#if defined(BSP_BOARD_S7G2_SK)
void g_lcd_spi_callback(spi_callback_args_t * p_args);
#endif

/***********************************************************************************************************************
    Private global variables
 ***********************************************************************************************************************/
static GX_EVENT g_gx_event;

GX_WINDOW_ROOT * p_window_root;
extern GX_CONST GX_STUDIO_WIDGET *certview_widget_table[];

static size_t slide_image_count = 0;
static GX_UBYTE sd_slide_buffer[RGB_BUFFER_SIZE]BSP_ALIGN_VARIABLE_V2(64) BSP_PLACE_IN_SECTION_V2(".sdram");
static size_t sd_slide_buffer_size = 0;
static GX_IMAGE_READER image_reader;

static GX_UBYTE * p_rgb_buffer = NULL;
static TX_BYTE_POOL guix_pool;
static UCHAR mem_guix_pool[2*RGB_BUFFER_SIZE+(298*1024)] BSP_ALIGN_VARIABLE_V2(64) BSP_PLACE_IN_SECTION_V2(".sdram");

static void * guix_malloc(ULONG size)
{
    void * p_mem = NULL;

    UINT tx_err = tx_byte_allocate(&guix_pool, &p_mem, size, TX_NO_WAIT);

    if (tx_err != TX_SUCCESS)
    {
        return NULL;
    }
    else
{
        return p_mem;
    }
}

static void guix_free(void * p_mem)
{
    UINT tx_err = tx_byte_release(p_mem);
    SSP_PARAMETER_NOT_USED(tx_err);
}

/*******************************************************************************************************************//**
    @brief  Primary logic for handling events generated by the various sub-systems.
 ***********************************************************************************************************************/
void display_thread_entry(void) {
    ssp_err_t        err;
    sf_message_header_t * p_message = NULL;
    UINT      status = TX_SUCCESS;

    /* Initialize a byte pool buffer */
    status = tx_byte_pool_create(&guix_pool, "GUIX Byte Pool", mem_guix_pool, sizeof(mem_guix_pool));

    /* Initializes GUIX. */
    status = gx_system_initialize();
    if(TX_SUCCESS != status)
    {
        while(1);
    }

    /* Initializes GUIX drivers. */
    err = g_sf_el_gx0.p_api->open (g_sf_el_gx0.p_ctrl, g_sf_el_gx0.p_cfg);
    if(SSP_SUCCESS != err)
    {
        while(1);
    }

    gx_studio_display_configure ( DISPLAY_1,
                                  g_sf_el_gx0.p_api->setup,
                                  LANGUAGE_ENGLISH,
                                  DISPLAY_1_THEME_1,
                                  &p_window_root );

    err = g_sf_el_gx0.p_api->canvasInit(g_sf_el_gx0.p_ctrl, p_window_root);
    if(SSP_SUCCESS != err)
    {
        while(1);
    }

    status = gx_system_memory_allocator_set(guix_malloc, guix_free);

    // Create the widgets we have defined with the GUIX data structures and resources.
    GX_CONST GX_STUDIO_WIDGET ** pp_studio_widget = &certview_widget_table[0];
    GX_WIDGET * p_first_screen = NULL;

    while (GX_NULL != *pp_studio_widget)
    {
        // We must first create the widgets according the data generated in GUIX Studio.

        // Once we are working on the widget we want to see first, save the pointer for later.
        if (0 == strcmp("window_main", (char*)(*pp_studio_widget)->widget_name))
        {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name, (GX_WIDGET *)p_window_root, GX_NULL);
        } else {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name, GX_NULL, GX_NULL);
        }
        // Move to next top-level widget
        pp_studio_widget++;
    }
    // Attach the first screen to the root so we can see it when the root is shown
   gx_widget_attach(p_window_root, p_first_screen);


    if(TX_SUCCESS != status)
    {
            while(1);
    }

    /* Shows the root window to make it and patients screen visible. */
    status = gx_widget_show(p_window_root);
    if(TX_SUCCESS != status)
    {
        while(1);
    }

    /* Lets GUIX run. */
    status = gx_system_start();
    if(TX_SUCCESS != status)
    {
        while(1);
    }

#if defined(BSP_BOARD_S7G2_SK)
    /** Open the SPI driver to initialize the LCD (SK-S7G2) **/
    err = g_spi_lcdc.p_api->open(g_spi_lcdc.p_ctrl, (spi_cfg_t *)g_spi_lcdc.p_cfg);
    if (err)
    {
        while(1);
    }
    /** Setup the ILI9341V (SK-S7G2) **/
    ILI9341V_Init();
#endif

    /* Controls the GPIO pin for LCD ON (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK)
    err = g_ioport.p_api->pinWrite(IOPORT_PORT_07_PIN_10, IOPORT_LEVEL_HIGH);
    if (err)
    {
        while(1);
    }
#elif defined(BSP_BOARD_S7G2_PE_HMI1)
    err = g_ioport.p_api->pinWrite(IOPORT_PORT_10_PIN_03, IOPORT_LEVEL_HIGH);
    if (err)
    {
        while(1);
    }
#endif

    /* Opens PWM driver and controls the TFT panel back light (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK) || defined(BSP_BOARD_S7G2_PE_HMI1)
    err = g_pwm_backlight.p_api->open(g_pwm_backlight.p_ctrl, g_pwm_backlight.p_cfg);
    if (err)
    {
        while(1);
    }
#endif

    while(1)
    {
        bool new_gui_event = false;

        err = g_sf_message0.p_api->pend(g_sf_message0.p_ctrl, &display_thread_message_queue, (sf_message_header_t **) &p_message, TX_WAIT_FOREVER);
        if (SSP_SUCCESS == err)
        {
            /** TODO: Handle error. */

            switch (p_message->event_b.class_code)
            {
                case SF_MESSAGE_EVENT_CLASS_TOUCH:
                {
                    switch (p_message->event_b.code)
                    {
                        case SF_MESSAGE_EVENT_NEW_DATA:
                        {
                            /** Translate an SSP touch event into a GUIX event */
                            new_gui_event = ssp_touch_to_guix((sf_touch_panel_payload_t*)p_message, &g_gx_event);
                        }
                        default:
                            break;
                    }
                }
                break;

                case SF_MESSAGE_EVENT_CLASS_MEDIA:
                {
                    switch (p_message->event_b.code)
                    {
                        case SF_MESSAGE_EVENT_NEW_DATA:
                        {
                            /** Translate an SSP touch event into a GUIX event */
                            slide_image_count = ((media_payload_t * )p_message)->payload.file_count;

                            /** Send event to GUI */
                            g_gx_event.gx_event_sender = GX_ID_NONE;
                            g_gx_event.gx_event_target = 0;
                            g_gx_event.gx_event_display_handle = 0;
                            g_gx_event.gx_event_type = GX_EVENT_PEN_DOWN;


                            g_gx_event.gx_event_payload.gx_event_pointdata.gx_point_x = 10;
                            g_gx_event.gx_event_payload.gx_event_pointdata.gx_point_y = 10;

                            gx_system_event_send(&g_gx_event);
                            g_gx_event.gx_event_type = GX_EVENT_PEN_UP;
                            gx_system_event_send(&g_gx_event);

                            if(slide_image_count == 0)
                            {
                                ;
                            }
                            else if(slide_image_count > 0)
                            {
                                sd_slide_buffer_size = RGB_BUFFER_SIZE;
//                                status |= tx_byte_allocate(&guix_pool, &p_rgb_buffer, sd_slide_buffer_size, TX_NO_WAIT);
                                err = message_display_requests_png(SF_MESSAGE_EVENT_NEW_DATA, DB_DEMO_SLIDES, 0, &sd_slide_buffer[0], &sd_slide_buffer_size);
                            }

                        }
                        default:
                            break;
                    }
                }
                    break;
                default:
                    break;
            }

            /** Message is processed, so release buffer. */
            err = g_sf_message0.p_api->bufferRelease(g_sf_message0.p_ctrl, (sf_message_header_t *) p_message, SF_MESSAGE_RELEASE_OPTION_ACK);

            if (err)
            {
                /** TODO: Handle error. */
            }
        }


        /** Post message. */
        if (new_gui_event) {
            gx_system_event_send(&g_gx_event);
        }
    }
}

static bool ssp_touch_to_guix(sf_touch_panel_payload_t * p_touch_payload, GX_EVENT * gx_event)
{
    bool send_event = true;

    switch (p_touch_payload->event_type)
    {
    case SF_TOUCH_PANEL_EVENT_DOWN:
        gx_event->gx_event_type = GX_EVENT_PEN_DOWN;
        break;
    case SF_TOUCH_PANEL_EVENT_UP:
        gx_event->gx_event_type = GX_EVENT_PEN_UP;
        break;
    case SF_TOUCH_PANEL_EVENT_HOLD:
    case SF_TOUCH_PANEL_EVENT_MOVE:
        gx_event->gx_event_type = GX_EVENT_PEN_DRAG;
        break;
    case SF_TOUCH_PANEL_EVENT_INVALID:
        send_event = false;
        break;
    default:
        break;
    }

    if (send_event)
    {
        /** Send event to GUI */
        gx_event->gx_event_sender = GX_ID_NONE;
        gx_event->gx_event_target = 0;
        gx_event->gx_event_display_handle = 0;

        gx_event->gx_event_payload.gx_event_pointdata.gx_point_x = p_touch_payload->x;

#if defined(BSP_BOARD_S7G2_SK)
        gx_event->gx_event_payload.gx_event_pointdata.gx_point_y = (320 - p_touch_payload->y);  // SK-S7G2
#else
        gx_event->gx_event_payload.gx_event_pointdata.gx_point_y = p_touch_payload->y;  // DK-S7G2, PE-HMI1
#endif
    }

    return send_event;
}

UINT window_slide_show_event_handler(GX_WINDOW *widget, GX_EVENT *event_ptr)
{
    bool run_process_event_routine = false;
    UINT result = GX_SUCCESS;

    switch (event_ptr->gx_event_type)
    {
        case GX_EVENT_TIMER:
        {
            gx_system_dirty_mark(widget);
        }
        break;

        case GX_SIGNAL(ID_WINDOW_EVENT_SLIDESHOW, GX_EVENT_SHOW):
        {
            result = gx_system_timer_start(widget, TIMER_ID, GX_TICKS_SECOND * 10, 0);
            run_process_event_routine = true;
        }
        break;

        default:
        {
            run_process_event_routine = true;
        }
        break;
    }

    result = (run_process_event_routine == true) ? gx_window_event_process(widget, event_ptr) : result;

    return result;
}

static GX_PIXELMAP const png_output =
{
 .gx_pixelmap_version_major=     0x00000001,                                                                 /* Pixelmap major version number            */
 .gx_pixelmap_version_minor=     0x00000000,                                                                 /* Pixelmap minor version number            */
 .gx_pixelmap_flags=             GX_PIXELMAP_COMPRESSED|GX_PIXELMAP_ALPHA|GX_PIXELMAP_RAW_FORMAT,            /* Flags defined below                      */
 .gx_pixelmap_format=            GX_COLOR_FORMAT_565RGB,                                                     /* Color format, defined below              */
 .gx_pixelmap_data=              NULL,                                                                       /* Pointer to pixelmap data                 */
 .gx_pixelmap_data_size=         0,                                                                          /* Size of the pixelmap data array          */
 .gx_pixelmap_aux_data=          NULL,                                                                       /* Auxiliary data array.                    */
 .gx_pixelmap_aux_data_size=     0,                                                                          /* Size of the auxiliary data array         */
 .gx_pixelmap_transparent_color= 0x00,                                                                       /* Used for translated GIF images           */
 .gx_pixelmap_width=             800,                                                                        /* Width - in pixels                        */
 .gx_pixelmap_height=            480                                                                         /* Height - in pixels                       */
};

static GX_PIXELMAP png_read;

void message_display_requests_png_callback(sf_message_callback_args_t * p_args)
{
    SSP_PARAMETER_NOT_USED(p_args);

    memcpy(&png_read, &png_output, sizeof(png_output));

    if(p_args->event == SF_MESSAGE_CALLBACK_EVENT_ACK)
    {
        png_read.gx_pixelmap_data   = sd_slide_buffer;
        png_read.gx_pixelmap_data_size  = sd_slide_buffer_size;
    }

    UINT tx_err = tx_event_flags_set(&g_display_event_flags, DISPLAY_IMAGE_BUFFER_LOADED, TX_OR);

    SSP_PARAMETER_NOT_USED(tx_err);

    return;
}

VOID window_slide_show_draw_handler(GX_WINDOW *widget)
{
    UINT x_err = GX_SUCCESS;
    static uint8_t show_id = 0;
    ULONG gx_widget_status = widget->gx_widget_status;
    ULONG display_event_flag = 0;


    gx_window_draw(widget);

    if(slide_image_count == 0)
    {
        x_err |= gx_window_wallpaper_set(widget, GX_PIXELMAP_ID_SLIDESHOW_BACKGROUND, GX_FALSE);
    }
    else if(gx_widget_status == (GX_STATUS_HAS_FOCUS|GX_STATUS_ACCEPTS_FOCUS|GX_STATUS_VISIBLE))
    {
        x_err = tx_event_flags_get(&g_display_event_flags,
                                                    (DISPLAY_IMAGE_BUFFER_LOADED),
                                                    (UINT)TX_OR_CLEAR,
                                                    &display_event_flag,
                                                    TX_WAIT_FOREVER);
        if(TX_SUCCESS==x_err)
        {
            x_err |= gx_canvas_pixelmap_draw(0, 0, &png_read);
            sd_slide_buffer_size = RGB_BUFFER_SIZE;
            if(++show_id >= slide_image_count)
            {
                show_id = 0;
            }
            ssp_err_t ssp_err = message_display_requests_png(SF_MESSAGE_EVENT_NEW_DATA, DB_DEMO_SLIDES, show_id, &sd_slide_buffer[0], &sd_slide_buffer_size);
            SSP_PARAMETER_NOT_USED(ssp_err);
        }
        x_err |= gx_system_timer_start(widget, TIMER_ID, TX_TIMER_TICKS_PER_SECOND * 5, 0);
    }

    SSP_PARAMETER_NOT_USED(x_err);

    return;
}

#if defined(BSP_BOARD_S7G2_SK)
void g_lcd_spi_callback(spi_callback_args_t * p_args)
{
    (void)p_args;
    tx_semaphore_ceiling_put(&g_main_semaphore_lcdc, 1);
}
#endif
